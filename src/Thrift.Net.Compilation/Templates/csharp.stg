document(version, file, model, typeMap) ::= <<
// <auto-generated>
// This file was generated by Thrift.Net version $version$. Do not edit this file
// directly - any changes may be lost.
// </auto-generated>
$if(model.CSharpNamespace)$
namespace $model.CSharpNamespace$
{
    $generateDocument(file, model, typeMap)$
}
$else$
$generateDocument(file, model, typeMap)$
$endif$
>>

generateDocument(file, model, typeMap) ::= <<
using System;
using System.Threading;
using System.Threading.Tasks;

using Thrift.Collections;
using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
$if(model.Constants)$

public static class $file.ConstantsClassName$
{
    $model.Constants:generateConstant(); separator="\n\n"$
}
$endif$
$if(model.Enums)$

$model.Enums:generateEnum(); separator="\n\n"$
$endif$
$if(model.Structs)$

$model.Structs:{struct | $generateMessage(struct, typeMap, false)$}; separator="\n\n"$
$endif$
$if(model.Unions)$

$model.Unions:{union | $generateMessage(union, typeMap, false)$}; separator="\n\n"$
$endif$
$if(model.Exceptions)$

$model.Exceptions:{exception | $generateMessage(exception, typeMap, true)$}; separator="\n\n"$
$endif$
>>

generateConstant(constant) ::= <<
public const $constant.Type.CSharpRequiredTypeName$ $constant.Name$ = $constant.Value.RawValue$;
>>

generateEnum(enum) ::= <<
public enum $enum.Name$
{
    $enum.Members:generateEnumMember(); separator=",\n"$
}
>>

generateEnumMember(member) ::= <<
$member.Name$ = $member.Value$
>>

generateMessage(message, typeMap, isException) ::= <<
$if(isException)$
public class $message.Name$ : TException, TBase
$else$
public class $message.Name$ : TBase
$endif$
{
$if(message.Fields)$
$if(message.OptionalFields)$
    private IsSetInfo isSet;
$endif$
    $message.Fields:generateBackingField(); separator="\n"$

$if(message.OptionalFields)$
    /// <summary>
    /// Gets information about whether each optional field has been set.
    /// </summary>
    public IsSetInfo IsSet
    {
        get { return this.isSet; }
    }

$endif$
    $message.Fields:generateField(); separator="\n\n"$

$endif$
    /// <inheritdoc />
    public async Task ReadAsync(TProtocol protocol, CancellationToken cancellationToken)
    {
        protocol.IncrementRecursionDepth();

        try
        {
            $if(message.RequiredFields)$
            $message.RequiredFields:declareIsSetVariable(); separator="\n"$

            $endif$
            await protocol.ReadStructBeginAsync(cancellationToken);
        
            while (true)
            {
                var field = await protocol.ReadFieldBeginAsync(cancellationToken);
                if (field.Type == TType.Stop)
                {
                    break;
                }

                switch (field.ID)
                {
$if(message.Fields)$
                    $message.Fields:{field | $generateReadFieldCaseStatement(field, typeMap)$}; separator="\n\n"$

$endif$
                    default: 
                        await TProtocolUtil.SkipAsync(protocol, field.Type, cancellationToken);

                        break;
                }

                await protocol.ReadFieldEndAsync(cancellationToken);
            }

            await protocol.ReadStructEndAsync(cancellationToken);
            $if(message.RequiredFields)$

            $message.RequiredFields:verifyRequiredFieldIsSet(); separator="\n\n"$
            $endif$
        }
        finally
        {
            protocol.DecrementRecursionDepth();
        }
    }

    /// <inheritdoc />
    public async Task WriteAsync(TProtocol protocol, CancellationToken cancellationToken)
    {
        protocol.IncrementRecursionDepth();

        try
        {
            var @struct = new TStruct("$message.Name$");
            await protocol.WriteStructBeginAsync(@struct, cancellationToken);
$if(message.Fields)$
            var field = new TField();

            $message.Fields:{field | $generateWriteField(field, typeMap)$}; separator="\n\n"$

$endif$      
            await protocol.WriteFieldStopAsync(cancellationToken);
            await protocol.WriteStructEndAsync(cancellationToken);
        }
        finally
        {
            protocol.DecrementRecursionDepth();
        }
    }
$if(message.Fields)$

    /// <inheritdoc />
    public override bool Equals(object obj)
    {
        return obj is $message.Name$ other && this.Equals(other);
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        var hashCode = new HashCode();
        $message.Fields:{f | hashCode.Add(this.$f.Name$);}; separator="\n"$

        return hashCode.ToHashCode();
    }

    private bool Equals($message.Name$ other)
    {
        if (object.ReferenceEquals(this, other))
        {
            return true;
        }

        return other != null &&
            $message.Fields:generateEqualsComparison(); separator=" &&\n"$;
    }

    /// <summary>
    /// Contains the Thrift Ids of all of the fields for use during serialization
    /// and deserialization.
    /// </summary>
    public static class FieldIds
    {
        $message.Fields:generateFieldId(); separator="\n\n"$
    }
$endif$
$if(message.OptionalFields)$

    /// <summary>
    /// Contains an entry for each optional field, indicating whether it has been
    /// set or not.
    /// </summary>
    public struct IsSetInfo
    {
        $message.OptionalFields:generateIsSetField(); separator="\n\n"$
    }
$endif$
}
>>

declareIsSetVariable(field) ::= <<
var isSet_$field.Name$ = false;
>>

verifyRequiredFieldIsSet(field) ::= <<
if (!isSet_$field.Name$)
{
    throw new TProtocolException(TProtocolException.INVALID_DATA);
}
>>

backingFieldName(field) ::= <<
_$field.Name$
>>

getFieldType(field) ::= <%
$if(field.IsRequired)$
$field.Type.CSharpRequiredTypeName$
$else$
$field.Type.CSharpOptionalTypeName$
$endif$
%>

generateBackingField(field) ::= <<
private $getFieldType(field)$ $backingFieldName(field)$;
>>

generateField(field) ::= <<
public $getFieldType(field)$ $field.Name$
{
    get
    {
        return $backingFieldName(field)$;
    }

    set
    {
        this.$backingFieldName(field)$ = value;
        $if(!field.IsRequired)$
        this.isSet.$field.Name$ = value != null;
        $endif$
    }
}
>>

generateFieldId(field) ::= <<
public const int $field.Name$ = $field.FieldId$;
>>

generateIsSetField(field) ::= <<
public bool $field.Name$;
>>

generateReadFieldCaseStatement(field, typeMap) ::= <<
case FieldIds.$field.Name$:
    if (field.Type == $getTType(field.Type, typeMap)$)
    {
        $generateReadMethod(qualifyWithThis(field.Name), field.Type, typeMap, false)$
        $if(field.IsRequired)$
        isSet_$field.Name$ = true;
        $endif$
    }
    else
    {
        await TProtocolUtil.SkipAsync(protocol, field.Type, cancellationToken);
    }
    
    break;
>>

generateReadMethod(variableName, type, typeMap, isNested) ::= <%
$if(type.IsBaseType)$
    $generateBaseTypeReadMethod(variableName, type, typeMap, isNested)$
$elseif(type.IsEnum)$
    $generateEnumReadMethod(variableName, type, isNested)$
$elseif(type.IsStruct)$
    $generateMessageReadMethod(variableName, type, isNested)$
$elseif(type.IsList)$
    $generateListReadMethod(variableName, type, typeMap, isNested)$
$elseif(type.IsSet)$
    $generateSetReadMethod(variableName, type, typeMap, isNested)$
$else$
    $generateMapReadMethod(variableName, type, typeMap, isNested)$
$endif$
%>

generateBaseTypeReadMethod(variableName, type, typeMap, isNested) ::= <<
$if(isNested)$var $endif$$variableName$ = await protocol.$typeMap.(type.Name).ReadMethodName$(cancellationToken);
>>

generateEnumReadMethod(variableName, type, isNested) ::= <<
$if(isNested)$var $endif$$variableName$ = ($type.CSharpRequiredTypeName$)await protocol.ReadI32Async(cancellationToken);
>>

generateMessageReadMethod(variableName, type, isNested) ::= <<
$if(isNested)$var $endif$$variableName$ = new $type.CSharpRequiredTypeName$();
await $variableName$.ReadAsync(protocol, cancellationToken);
>>

generateListReadMethod(variableName, type, typeMap, isNested) ::= <<
var $getCollectionVariableName("listInfo", type.NestingDepth)$ = await protocol.ReadListBeginAsync(cancellationToken);
$if(isNested)$var $endif$$variableName$ = new $type.CSharpRequiredTypeName$($getCollectionVariableName("listInfo", type.NestingDepth)$.Count);

for (var $getCollectionVariableName("i", type.NestingDepth)$ = 0; $getCollectionVariableName("i", type.NestingDepth)$ < $getCollectionVariableName("listInfo", type.NestingDepth)$.Count; $getCollectionVariableName("i", type.NestingDepth)$++)
{
    $generateReadMethod(getCollectionVariableName("element", type.NestingDepth), type.ElementType, typeMap, true)$
    $variableName$.Add($getCollectionVariableName("element", type.NestingDepth)$);
}

await protocol.ReadListEndAsync(cancellationToken);
>>

generateSetReadMethod(variableName, type, typeMap, isNested) ::= <<
var $getCollectionVariableName("setInfo", type.NestingDepth)$ = await protocol.ReadSetBeginAsync(cancellationToken);
$if(isNested)$var $endif$$variableName$ = new $type.CSharpRequiredTypeName$($getCollectionVariableName("setInfo", type.NestingDepth)$.Count);

for (var $getCollectionVariableName("i", type.NestingDepth)$ = 0; $getCollectionVariableName("i", type.NestingDepth)$ < $getCollectionVariableName("setInfo", type.NestingDepth)$.Count; $getCollectionVariableName("i", type.NestingDepth)$++)
{
    $generateReadMethod(getCollectionVariableName("element", type.NestingDepth), type.ElementType, typeMap, true)$
    $variableName$.Add($getCollectionVariableName("element", type.NestingDepth)$);
}

await protocol.ReadSetEndAsync(cancellationToken);
>>

generateMapReadMethod(variableName, type, typeMap, isNested) ::= <<
var $getCollectionVariableName("mapInfo", type.NestingDepth)$ = await protocol.ReadMapBeginAsync(cancellationToken);
$if(isNested)$var $endif$$variableName$ = new $type.CSharpRequiredTypeName$($getCollectionVariableName("mapInfo", type.NestingDepth)$.Count);

for (var $getCollectionVariableName("i", type.NestingDepth)$ = 0; $getCollectionVariableName("i", type.NestingDepth)$ < $getCollectionVariableName("mapInfo", type.NestingDepth)$.Count; $getCollectionVariableName("i", type.NestingDepth)$++)
{
    $generateReadMethod(getCollectionVariableName("key", type.NestingDepth), type.KeyType, typeMap, true)$

    $generateReadMethod(getCollectionVariableName("value", type.NestingDepth), type.ValueType, typeMap, true)$
    
    $variableName$[$getCollectionVariableName("key", type.NestingDepth)$] = $getCollectionVariableName("value", type.NestingDepth)$;
}

await protocol.ReadMapEndAsync(cancellationToken);
>>

generateWriteField(field, typeMap) ::= <<
$if(field.IsRequired)$$generateWriteFieldInner(field, typeMap)$$else$if (this.$field.Name$ != null && this.IsSet.$field.Name$)
{
    $generateWriteFieldInner(field, typeMap)$
}$endif$
>>

generateWriteFieldInner(field, typeMap) ::= <<
field.Name = "$field.Name$";
field.ID = FieldIds.$field.Name$;
field.Type = $getTType(field.Type, typeMap)$;

await protocol.WriteFieldBeginAsync(field, cancellationToken);
$generateWriteMethod(qualifyWithThis(field.Name), field.Type, typeMap)$
await protocol.WriteFieldEndAsync(cancellationToken);
>>

generateWriteMethod(variableName, type, typeMap) ::= <%
$if(type.IsBaseType)$
    $generateBaseTypeWriteMethod(variableName, type, typeMap)$
$elseif(type.IsEnum)$
    $generateEnumWriteMethod(variableName)$
$elseif(type.IsStruct)$
    $generateMessageWriteMethod(variableName)$
$elseif(type.IsList)$
    $generateListWriteMethod(variableName, type, typeMap)$
$elseif(type.IsSet)$
    $generateSetWriteMethod(variableName, type, typeMap)$
$else$
    $generateMapWriteMethod(variableName, type, typeMap)$
$endif$
%>

generateBaseTypeWriteMethod(variableName, type, typeMap) ::= <%
$! TODO: $variableName$ ?? default doesn't work for bool, so probably want to add something to indicate if the type is nullable !$
await protocol.$typeMap.(type.Name).WriteMethodName$($variableName$ ?? default, cancellationToken);
%>

generateEnumWriteMethod(variableName) ::= <%
await protocol.WriteI32Async((int)$variableName$, cancellationToken);
%>

generateMessageWriteMethod(variableName) ::= <%
await $variableName$.WriteAsync(protocol, cancellationToken);
%>

generateListWriteMethod(variableName, type, typeMap) ::= <<
await protocol.WriteListBeginAsync(new TList($getTType(type.ElementType, typeMap)$, $variableName$.Count), cancellationToken);

foreach (var $getCollectionVariableName("element", type.NestingDepth)$ in $variableName$)
{
    $generateWriteMethod(getCollectionVariableName("element", type.NestingDepth), type.ElementType, typeMap)$
}

await protocol.WriteListEndAsync(cancellationToken);
>>

generateSetWriteMethod(variableName, type, typeMap) ::= <<
await protocol.WriteSetBeginAsync(new TSet($getTType(type.ElementType, typeMap)$, $variableName$.Count), cancellationToken);

foreach (var $getCollectionVariableName("element", type.NestingDepth)$ in $variableName$)
{
    $generateWriteMethod(getCollectionVariableName("element", type.NestingDepth), type.ElementType, typeMap)$
}

await protocol.WriteSetEndAsync(cancellationToken);
>>

generateMapWriteMethod(variableName, type, typeMap) ::= <<
await protocol.WriteMapBeginAsync(new TMap($getTType(type.KeyType, typeMap)$, $getTType(type.ValueType, typeMap)$, $variableName$.Count), cancellationToken);

foreach (var $getCollectionVariableName("pair", type.NestingDepth)$ in $variableName$)
{
    $generateWriteMethod(getKeyVariableName("pair", type.NestingDepth), type.KeyType, typeMap)$

    $generateWriteMethod(getValueVariableName("pair", type.NestingDepth), type.ValueType, typeMap)$
}

await protocol.WriteMapEndAsync(cancellationToken);
>>

getTType(type, typeMap) ::= <%
$if(type.IsBaseType)$
    $typeMap.(type.Name).TypeName$
$elseif(type.IsEnum)$
    TType.I32
$elseif(type.IsStruct)$
    TType.Struct
$elseif(type.IsList)$
    TType.List
$elseif(type.IsSet)$
    TType.Set
$else$
    TType.Map
$endif$
%>

getCollectionVariableName(name, nestingDepth) ::= <%
$name$$nestingDepth$
%>

getKeyVariableName(variableName, nestingDepth) ::= <<
$getCollectionVariableName(variableName, nestingDepth)$.Key
>>

getValueVariableName(variableName, nestingDepth) ::= <<
$getCollectionVariableName(variableName, nestingDepth)$.Value
>>

qualifyWithThis(name) ::= <%
this.$name$
%>

generateEqualsComparison(field) ::= <%
$if(field.Type.IsCollection)$
    TCollections.Equals(this.$field.Name$, other.$field.Name$)
$else$
    object.Equals(this.$field.Name$, other.$field.Name$)
$endif$
%>
